#!/usr/bin/env python
"""
pdfposter - scale and tile PDF images/pages to print on multiple pages.
"""
#
# Copyright 2008 by Hartmut Goebel <h.goebel@goebel-consult.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

__author__ = "Hartmut Goebel <h.goebel@goebel-cosnult.de>"
__copyright__ = "Copyright 2008 by Hartmut Goebel <h.goebel@goebel-consult.de>"
__licence__ = "GNU General Public License version 3 (GPL v3)"
__version__ = "0.1"

from pyPdf.pdf import PdfFileWriter, PdfFileReader, PageObject, getRectangle, \
     ArrayObject, ContentStream, NameObject, FloatObject, RectangleObject

import re
import logging
from logging import log

# pattern for parsing user textual box spec
pat_box = re.compile(r'''
     ( (?P<width> \d*) x (?P<height> \d*) )?       # width "x" height
     (?P<offset> \+                                # "+" offset_x "," offset_y
                 (?P<offset_x> \d+\.? | \d*\.\d+)
                 ,
                 (?P<offset_y> \d+\.? | \d*\.\d+) ) ?
     (?P<unit> [a-z][a-z0-9\-\\_]?)                # unit
     ''', re.X+re.I)

DEFAULT_MEDIASIZE = 'a4'

# Taken from poster.c
papersizes = {
    'pt'  : (1, 1),
    'inch': (72, 72),
    'ft'  : (864, 864), # 12 inch
    'mm'  : (72     / 25.4, 72     / 25.4),
    'cm'  : (72     / 2.54, 72     / 2.54),
    'm'   : (72*100 / 2.54, 72*100 / 2.54),

    "monarch"  : (279, 540),
    "statement": (396, 612),
    "executive": (540, 720),
    "quarto"   : (610, 780),
    "letter"   : (612, 792),
    "folio"    : (612, 936),
    "legal"    : (612, 1008),
    "tabloid"  : (792, 1224),
    "ledger"   : (792, 1224),

    "a0" : (2384, 3370),
    "a1" : (1684, 2384),
    "a2" : (1191, 1684),
    "a3" : (842, 1191),
    "a4" : (595, 842),
    "a5" : (420, 595),
    "a6" : (298, 420),
    "a7" : (210, 298),
    "a8" : (147, 210),
    "a9" : (105, 147),
    "a10": (74, 105),

    "dinlang"   : (281, 595), # 1/3 a4
    "envdinlang": (312, 624), # envelobe for din-lang

    "b0" : (2835, 4008),
    "b1" : (2004, 2835),
    "b2" : (1417, 2004),
    "b3" : (1001, 1417),
    "b4" : (709, 1001),
    "b5" : (499, 709),
    "b6" : (354, 499),
    "b7" : (249, 354),
    "b8" : (176, 249),
    "b9" : (125, 176),
    "b10": (88, 125),

    "c4" : (649, 918),
    "c5" : (459, 649),
    "c6" : (323, 459),

    "jb0" : (2920, 4127),
    "jb1" : (2064, 2920),
    "jb2" : (1460, 2064),
    "jb3" : (1032, 1460),
    "jb4" : (729, 1032),
    "jb5" : (516, 729),
    "jb6" : (363, 516),
    "jb7" : (258, 363),
    "jb8" : (181, 258),
    "jb9" : (128, 181),
    "jb10": (91, 128),

    "comm10": (298, 684),
    "com10" : (298, 684),
    "env10" : (298, 684),
    }

PAGE_BOXES = ("/MediaBox", "/CropBox", "/BleedBox", "/TrimBox", "/ArtBox")

def copyPage(page):
    from pyPdf.pdf import RectangleObject, NameObject
    newpage = PageObject(page.pdf)
    newpage.update(page)
    # Copy Rectangles to be manipulatable
    for attr in PAGE_BOXES:
        if page.has_key(attr):
            newpage[NameObject(attr)] = RectangleObject(list(page[attr]))
    return newpage


def posterize(page, outpdf, width=None, height=None,
              offset_x=None, offset_y=None, **args2ignore):
    # todo: is the crop box the correct box to work on?
    box = page.cropBox
    total_width  = float(box.upperRight[0])
    total_height = float(box.upperRight[1])
    target_media_box = RectangleObject((0,0,width,height))
    # area to put on each page (allows for overlay of margin)
    # (not yet implemented)
    h_step = width -offset_x
    v_step = height-offset_y
    h_pos = 0
    while h_pos < total_width:
        v_pos = 0
        while v_pos < total_height:
            log(15, 'page poffset: %.2f %.2f' % (h_pos, v_pos))
            newpage = copyPage(page)
            newpage.mediaBox.lowerLeft= (h_pos, v_pos)
            newpage.mediaBox.upperRight = (h_pos + width,
                                           v_pos + height)
            #print newpage.cropBox
            #print '###'
            outpdf.addPage(newpage)
            v_pos += v_step
        h_pos += h_step

    
def _scale(page, factor):
    for boxname in PAGE_BOXES:
        # skip if real box does not exits (avoid fallback to other boxes)
        if not page.get(boxname):
            continue
        box = getRectangle(page, boxname, None)
        box.lowerLeft  = [i * factor for i in box.lowerLeft ]
        box.upperRight = [i * factor for i in box.upperRight]
        #print boxname, type(box), box
    # put transformation matrix in front of page content
    content = ContentStream(page["/Contents"].getObject(), page.pdf)
    content.operations.insert(0, [[], '%f 0 0 %f 0 0 cm' %(factor,factor)] )
    page[NameObject('/Contents')] = content


def scale(page, width=None, height=None, **args2ignore):
    box = page.trimBox
    src_width  = box.upperRight[0] - box.lowerLeft[0] 
    src_height = box.upperRight[1] - box.lowerLeft[1] 
    if (height > width) != (src_height > src_width):
        log(19, 'rotating page')
        page.rotateClockwise(90)
        src_width, src_height = src_height, src_width
    factor = min(width/src_width, height/src_height)
    log(18, 'old dimensions: %.2f %.2f (input pagesize)', src_width, src_height)
    log(15, 'new dimensions: %.2f %.2f (poster size)', width, height)
    log(19, 'page scaling factor: %f', factor)
    _scale(page, factor)


def main(opts, infilename, outfilename):
    logging.basicConfig(level=20-opts.verbose, format="%(message)s")
    outpdf = PdfFileWriter()
    inpdf = PdfFileReader(open(infilename))

    log(17, 'Mediasize : %(units_x)sx%(units_y)s %(unit)s' % opts.media_size)
    log(15, '            %(width).2f %(height).2f dots' % opts.media_size)
    log(12, 'Postersize: %(units_x)sx%(units_y)s %(unit)s' % opts.poster_size)
    log(15, '            %(width).2f %(height).2f dots' % opts.poster_size)

    for i, page in enumerate(inpdf.pages):
        log(20, '---- processing page %i -----', i+1)
        # todo: crop to inbox
        scale(page, **opts.poster_size)
        posterize(page, outpdf, **opts.media_size)
    outpdf.write(open(outfilename, 'wb'))


def __parse_box(option, value, parser, allow_offset=False):
    m = pat_box.match(value)
    if not m:
        raise parser.error("I don't understand your box specification %r for %s" % (value, option))
    res = m.groupdict()
    if not allow_offset and res['offset'] is not None:
        raise parser.errot('Offset not allowed in box definition for %s' % option)
    # res['offset'] is only used for error checking, remove it
    del res['offset']

    # get meassures of unit
    unit = res['unit'].lower()
    if not papersizes.has_key(unit):
        unit = [name for name in papersizes.keys()
                if name.startswith(unit)]
        if len(unit) != 1:
            parser.error('Your box spec %r for %s is not unique, give more chars.' % (res['unit'], option))
        unit = unit[0]
    unit_x, unit_y = papersizes[unit]
    res2 = {
        'width'   : float(res['width'] or 1) * unit_x,
        'height'  : float(res['height'] or 1) * unit_y,
        'offset_x': float(res['offset_x'] or 0) * unit_x,
        'offset_y': float(res['offset_y'] or 0) * unit_y,
        'unit': res['unit'],
        'units_x': res['width'] or 1,
        'units_y': res['height'] or 1,
        }
    return res2

def _parse_box(option, opt, value, parser, allow_offset=False):
    res = __parse_box(option, value, parser, allow_offset=False)
    setattr(parser.values, option.dest, res)


if __name__ == '__main__':
    import optparse
    parser = optparse.OptionParser('%program [options] InputFile OutputFile')
    parser.add_option('-v', '--verbose', action='count', default=0)
    
    group = parser.add_option_group('Define Target')
    group.add_option('-m', '--media-size', default=__parse_box('-m', DEFAULT_MEDIASIZE, parser),
                     action='callback', type='string', callback=_parse_box, 
                     help='Specify the size of the output media size (default: %default)')
    group.add_option('-p', '--poster-size',
                     action='callback', type='string', callback=_parse_box, 
                     help='Specify the poster size (defaults to media size). ')

##     parser.add_option('--info', action='store_true',
##                       help='Print information about scaling, rotation and number of pages')
##     parser.add_option('-n', '--dry-run', action='store_true',
##                       help='show what would have been done, but do not generate files')

    opts, args = parser.parse_args()

    if len(args) != 2:
        parser.error('requires both input and output filename')
    if not opts.poster_size:
        opts.poster_size = opts.media_size
    main(opts, *args)
